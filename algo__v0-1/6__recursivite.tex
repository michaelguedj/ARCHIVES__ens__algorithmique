




%%%
\subsection{Considérations sur la récursivité}

La version itérative d'un traitement est souvent à préférer.

En effet :
\begin{itemize}
	\item[--] Un dépassement de pile (\textit{stack overflow}) peut se produire ;
	\item[--] L'exécution d'une version récursive d'un algorithme est généralement un peu moins rapide 
			que celle de la version itérative correspondante ; 
			et ce même si le nombre d'instructions est le même (à cause de la gestion des appels de fonction) ;
	\item[--] Un algorithme récursif (naïf) peut conduire à exécuter bien plus d'instructions 
			que la version itérative correspondante (cas du calcul de la suite de Fibonacci).
\end{itemize}

\noindent
En revanche, la récursivité peut être adaptée dans certains cas.

En effet :
\begin{itemize}
	\item[--] Sur des structures de données naturellement récursives, 
	il est plus facile d'écrire des algorithmes récursifs qu'itératifs ;
	\item[--] Certains algorithmes sont, en outre, difficiles à écrire en itératif.
\end{itemize}


%%%
\subsection{Exemple 1 : la fonction factorielle}
\blue{
\begin{fDefinition}[fonction factorielle]
La fonction factorielle est définie, sur $\mathbb{N}$, par :
$$
\left\{
    \begin{array}{ll}
        0! = 1 						& \\
        n! = \Pi_{i=1}^{n} i = n\times (n-1) \times ... \times 2 \times 1 & \mbox{ si } n\geq 1
    \end{array}
\right.
$$
\end{fDefinition}
}

\blue{
\begin{fDefinition}[définition récursive de la fonction factorielle]
$$
n! = 
\left\{
    \begin{array}{ll}
        0 			& \mbox{si } n=0\\
        n\times (n-1)! & \mbox{si } n\geq 1
    \end{array}
\right.
$$
\end{fDefinition}
}

\begin{algorithm}[H]
\caption{$\algo{fact}(n\in\mathbb{N})$}
\begin{algorithmic}[1]
\If{$n = 0$}
	\State\Return 1
\Else
	\State\Return $n \times \textsc{fact}(n-1)$
\EndIf
\end{algorithmic}
\end{algorithm}

Complexité : $O(n)$


\begin{algorithm}[H]
\caption{$\algo{fact\_it}(n\in\mathbb{N})$}
\begin{algorithmic}[1]
\State $res\gets 1$
\For{$i\gets 1, ..., n$}
	\State $res \gets res \times i$
\EndFor
\State\Return $res$
\end{algorithmic}
\end{algorithm}

Complexité : $O(n)$

%%%
%%%
%%%
%%%
%%%
\subsection{Exemple 2 : la suite de Fibonacci}
\blue{
\begin{fDefinition}[suite de Fibonacci]
$$
F_n = 
\left\{
    \begin{array}{ll}
        0 				& \mbox{si } n=0\\
        1					& \mbox{si } n= 1\\
        F_{n-1} + F_{n-2}	& \mbox{si } n\geq 2\\
    \end{array}
\right.
$$
\end{fDefinition}
}

\begin{algorithm}[H]
\caption{$\algo{fibo}(n\in\mathbb{N})$}
\begin{algorithmic}[1]
\If{$n = 0$}
	\State\Return 0
\ElsIf{$n = 1$}
	\State\Return 1
\Else
	\State\Return $\textsc{fibo}(n-1) + \textsc{fibo}(n-2)$
\EndIf
\end{algorithmic}
\end{algorithm}
